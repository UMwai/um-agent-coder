#!/usr/bin/env python3
"""Subagent script for map_interactions"""
import sys
sys.path.insert(0, "src")

from um_agent_coder.llm.providers.mcp_local import MCPLocalLLM

# Configure model
model = MCPLocalLLM(backend="claude")

# Build prompt
prompt = """Based on the code analysis, map the interactions between the orchestrator components. How does data flow from task decomposition to execution? Where are the Subagents invoked? What are the external dependencies?"""

# Add context from prior steps
context = """{
  "read_source_code": "I have read the content of the specified files in `src/um_agent_coder/orchestrator/`.\n\nHere is a brief summary of the orchestrator architecture based on the code:\n\n*   **`multi_model.py`**: Contains `MultiModelOrchestrator`, which coordinates the entire workflow. It uses `TaskDecomposer` to break down requests and executes them via a pipeline.\n*   **`task_decomposer.py`**: Breaks complex user prompts into structured `DecomposedTask`s containing multiple `SubTask`s with dependencies and model assignments (Gemini, Codex, Claude).\n*   **`parallel_executor.py`**: Handles the execution of `DecomposedTask`s. It supports various execution modes (`SEQUENTIAL`, `PARALLEL_THREADS`, `PARALLEL_ASYNC`, `CLAUDE_CODE_SPAWN`) and manages dependencies between subtasks.\n*   **`claude_subagent.py`**: Defines `ClaudeCodeSubagentSpawner` for creating specialized subagents (Explore, Code Reviewer, Architect, etc.). It currently has a placeholder for a native \"Task tool\" integration and falls back to spawning subprocesses that run python scripts using `MCPLocalLLM`.\n*   **`data_fetchers.py`**: Provides standardized interfaces (`DataFetcher`) for external sources like SEC Edgar, Yahoo Finance, ClinicalTrials.gov, and News APIs.\n\nI am ready for your next instruction.",
  "analyze_components": "# Orchestrator Module Analysis\n\nBased on my previous reading of the source files, here is the detailed analysis of the orchestrator module:\n\n## File: `src/um_agent_coder/orchestrator/multi_model.py`\n\n### Main Classes\n\n**`MultiModelOrchestrator`**\n- **Purpose**: Top-level coordinator that manages the entire multi-model workflow pipeline\n- **Key Methods**:\n  - `__init__()` - Initializes with LLM providers (Gemini, Codex, Claude) and sets up TaskDecomposer and ParallelExecutor\n  - `orchestrate(prompt)` - Main entry point that decomposes a task and executes it through the pipeline\n  - `_execute_pipeline()` - Runs the 4-phase workflow (gather context \u2192 plan \u2192 execute \u2192 synthesize)\n- **Dependencies**: Uses `TaskDecomposer` for breaking down requests, `ParallelExecutor` for running subtasks\n\n---\n\n## File: `src/um_agent_coder/orchestrator/task_decomposer.py`\n\n### Main Classes\n\n**`SubTask`** (dataclass)\n- **Purpose**: Represents a single unit of work within a decomposed task\n- **Key Fields**: `id`, `description`, `model_assignment` (gemini/codex/claude), `dependencies` (list of subtask IDs), `priority`, `estimated_tokens`\n\n**`DecomposedTask`** (dataclass)\n- **Purpose**: Container for a fully decomposed request\n- **Key Fields**: `original_prompt`, `subtasks` (list of SubTask), `execution_order`, `metadata`\n\n**`TaskDecomposer`**\n- **Purpose**: Breaks complex user prompts into structured subtasks with dependency graphs\n- **Key Methods**:\n  - `decompose(prompt)` - Analyzes prompt and returns a `DecomposedTask`\n  - `_identify_subtasks()` - Parses prompt to extract individual work units\n  - `_assign_models()` - Routes each subtask to appropriate model (Gemini for research, Codex for code, Claude for decisions)\n  - `_build_dependency_graph()` - Determines execution order based on dependencies\n\n---\n\n## File: `src/um_agent_coder/orchestrator/parallel_executor.py`\n\n### Main Classes\n\n**`ExecutionMode`** (Enum)\n- **Purpose**: Defines available execution strategies\n- **Values**: `SEQUENTIAL`, `PARALLEL_THREADS`, `PARALLEL_ASYNC`, `CLAUDE_CODE_SPAWN`\n\n**`SubTaskResult`** (dataclass)\n- **Purpose**: Holds the result of an executed subtask\n- **Key Fields**: `subtask_id`, `success`, `result`, `error`, `execution_time`, `model_used`\n\n**`ParallelExecutor`**\n- **Purpose**: Executes `DecomposedTask`s with support for parallel execution and dependency management\n- **Key Methods**:\n  - `execute(decomposed_task, mode)` - Main entry point for task execution\n  - `_execute_sequential()` - Runs subtasks one-by-one in dependency order\n  - `_execute_parallel_threads()` - Uses ThreadPoolExecutor for concurrent execution\n  - `_execute_parallel_async()` - Uses asyncio for async concurrent execution\n  - `_execute_claude_spawn()` - Spawns Claude Code subagents for subtasks\n  - `_execute_subtask()` - Routes a single subtask to the appropriate LLM provider\n  - `_wait_for_dependencies()` - Blocks until a subtask's dependencies are satisfied\n- **Interfaces**: Expects LLM providers to implement a common interface with `generate()` or similar methods\n\n---\n\n## File: `src/um_agent_coder/orchestrator/claude_subagent.py`\n\n### Main Classes\n\n**`SubagentType`** (Enum)\n- **Purpose**: Defines specialized subagent roles\n- **Values**: `EXPLORE`, `CODE_REVIEWER`, `ARCHITECT`, `PLAN`, `GENERAL_PURPOSE`, etc.\n\n**`SubagentConfig`** (dataclass)\n- **Purpose**: Configuration for spawning a subagent\n- **Key Fields**: `type`, `prompt`, `model`, `run_in_background`, `timeout`\n\n**`SubagentResult`** (dataclass)\n- **Purpose**: Result from a completed subagent execution\n- **Key Fields**: `agent_id`, `success`, `output`, `error`, `execution_time`\n\n**`ClaudeCodeSubagentSpawner`**\n- **Purpose**: Factory for creating specialized Claude Code subagents\n- **Key Methods**:\n  - `spawn(config)` - Creates and runs a subagent based on config\n  - `spawn_explore()` - Shortcut for exploration-type subagent\n  - `spawn_code_reviewer()` - Shortcut for code review subagent\n  - `spawn_architect()` - Shortcut for architecture/planning subagent\n  - `_spawn_via_task_tool()` - Placeholder for native Task tool integration\n  - `_spawn_via_subprocess()` - Fallback that spawns a Python subprocess using `MCPLocalLLM`\n- **Note**: Currently uses subprocess fallback; native Task tool integration is stubbed\n\n---\n\n## File: `src/um_agent_coder/orchestrator/data_fetchers.py`\n\n### Main Classes\n\n**`DataFetcher`** (ABC - Abstract Base Class)\n- **Purpose**: Defines interface for all data fetching implementations\n- **Key Methods**:\n  - `fetch(query)` - Abstract method to retrieve data\n  - `validate()` - Check if fetcher is properly configured\n  - `get_rate_limit_status()` - Return current rate limiting info\n\n**`SECEdgarFetcher(DataFetcher)`**\n- **Purpose**: Fetches SEC filings (10-K, 10-Q, 8-K) from Edgar\n- **Key Methods**: `fetch(ticker, filing_type)`, `_parse_filing()`\n\n**`YahooFinanceFetcher(DataFetcher)`**\n- **Purpose**: Retrieves stock data, financials, and company info from Yahoo Finance\n- **Key Methods**: `fetch(ticker)`, `get_historical()`, `get_financials()`\n\n**`ClinicalTrialsFetcher(DataFetcher)`**\n- **Purpose**: Queries ClinicalTrials.gov for trial data\n- **Key Methods**: `fetch(condition, status)`, `_parse_trial()`\n\n**`NewsAPIFetcher(DataFetcher)`**\n- **Purpose**: Fetches news articles from News APIs\n- **Key Methods**: `fetch(query, sources)`, `get_top_headlines()`\n\n---\n\n## Inheritance & Interface Summary\n\n```\nDataFetcher (ABC)\n\u251c\u2500\u2500 SECEdgarFetcher\n\u251c\u2500\u2500 YahooFinanceFetcher\n\u251c\u2500\u2500 ClinicalTrialsFetcher\n\u2514\u2500\u2500 NewsAPIFetcher\n\nExecutionMode (Enum)\nSubagentType (Enum)\n\nDataclasses (no inheritance):\n\u251c\u2500\u2500 SubTask\n\u251c\u2500\u2500 DecomposedTask\n\u251c\u2500\u2500 SubTaskResult\n\u251c\u2500\u2500 SubagentConfig\n\u2514\u2500\u2500 SubagentResult\n\nOrchestration Classes (composition-based):\n\u251c\u2500\u2500 TaskDecomposer (standalone)\n\u251c\u2500\u2500 ParallelExecutor (uses LLM providers)\n\u251c\u2500\u2500 ClaudeCodeSubagentSpawner (standalone factory)\n\u2514\u2500\u2500 MultiModelOrchestrator (composes TaskDecomposer + ParallelExecutor)\n```\n\nThe architecture follows a **composition over inheritance** pattern for the orchestration classes, with inheritance used only for the data fetchers where a common interface is needed."
}"""
if context and context != "{}":
    prompt += f"\n\n--- CONTEXT FROM PREVIOUS STEPS ---\n{context}"

# Execute
try:
    result = model.chat(prompt)
    print(result)
except Exception as e:
    print(f"Error: {e}", file=sys.stderr)
    sys.exit(1)
